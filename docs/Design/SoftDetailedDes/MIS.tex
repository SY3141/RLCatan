\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{comment}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
11/13/2025 & 1.0 & Draft Rev 1\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/SY3141/RLCatan}.

%\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
our project RLCatan. This project aims to create a competent reinforcement learning AI agent designed to master the board game Settlers of Catan through autonomous self-play training. The AI will use deep reinforcement learning algorithms to learn optimal decision-making strategies across several game states including resource management, territory expansion and adaptive responses to opponent actions.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/SY3141/RLCatan}.

\section{Notation}

%\wss{You should describe your notation.  You can use what is below as
%  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
  \renewcommand{\arraystretch}{1.2}
  \noindent 
  \begin{tabular}{l l p{7.5cm}} 
  \toprule 
  \textbf{Type/Symbol} & \textbf{Notation} & \textbf{Description}\\ 
  \midrule
  % Primitive Types
  boolean & $\mathbb{B}$ & a logical value, either true ($\top$) or false ($\bot$) \\
  character & char & a single symbol or digit\\
  integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
  natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
  real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
  string & $\Sigma^*$ & a sequence of zero or more characters. \\
  sequence & seq of T & a list of zero or more elements of the same type T. \\
  tuple & (T1, T2, ...) & a finite, ordered list of elements, potentially of
                          different types. \\
  dictionary & dict & a collection of key-value mappings (ex, KeyType $\rightarrow$ ValueType). \\
  function & T1 $\rightarrow$ T2 & a function mapping an input of type T1 to
                          an output of type T2. \\
  true & $\top$ & the boolean value for true. \\
  false / null & $\bot$ & the boolean value for false, or a value that is
                          undefined, null, or void (no output). \\
  \bottomrule
  \end{tabular} 
  \end{center}

\noindent
In addition, \progname \ uses abstract
 data types (e.g., \texttt{FrameData}, 
 \texttt{GameStateData}, \texttt{AIMove})
  which are defined by their use in the 
  modules that hide their implementation 
  details. Local functions are described by
   giving their type signature followed by
    their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

\multirow{2}{0.3\textwidth}{Hardware-Hiding Module} & Hardware-Hiding Module (OS) \\
& Computer Vision Model \\
\midrule

\multirow{3}{0.3\textwidth}{Behaviour-Hiding Module} &  User Interface \\
&  Game State Manager \\
&  Reinforcement Learning Environment \\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} &  AI Model \\
& Game State Database \\
&  Image Queue \\
\bottomrule

\end{tabular}
\end{table}

\newpage
~\newpage


%%%%%%%%%%%%%%%%%ADDED MODULES BELOW THIS LINE%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Hardware-Hiding Module} \label{M1}

\subsection{Module}
Hardware-Hiding Module (M1)

\subsection{Uses}
\begin{itemize}
    \item \textbf{FrameData (Data Type):} Represents the raw image data captured from the camera or a simulated source.
    \item \textbf{HardwareInitError, CaptureError, HardwareShutdownError (Exception Types):} Indicate errors that may occur during hardware initialization, frame capture, or shutdown processes.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{CAMERA\_RESOLUTION}: tuple of $(\mathbb{Z}, \mathbb{Z})$ - width and height of captured frames
\item \texttt{FRAME\_RATE}: $\mathbb{R}$ - frames per second captured by the hardware layer
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
initializeHardware & - & $\mathbb{B}$ & HardwareInitError \\
captureFrame & - & FrameData & CaptureError \\
shutdownHardware & - & $\mathbb{B}$ & HardwareShutdownError \\
isInitialized & - & $\mathbb{B}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{hardwareStatus}: $\mathbb{B}$ \\
      Indicates whether the hardware subsystem has been successfully initialized.
\item \texttt{frameBuffer}: FrameData \\
      Stores the most recent frame captured from the camera.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{CameraDevice}: external hardware input for image capture
\item \texttt{DisplayInterface}: external interface for visualization
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item The CameraDevice is available and functional within the operating environment.
  \item Calling modules will invoke \texttt{isInitialized()} before executing 
        \texttt{captureFrame()} or \texttt{shutdownHardware()}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent initializeHardware():
\begin{itemize}
\item transition: Attempts connection to \texttt{CameraDevice}.  
      If successful: \texttt{hardwareStatus} := $\top$.
\item output: Returns initialization success status: $\mathbb{B}$
\item exception: raises \texttt{HardwareInitError} if initialization fails.
\end{itemize}

\noindent captureFrame():
\begin{itemize}
\item transition: Reads a new frame from \texttt{CameraDevice} into \texttt{frameBuffer}.
\item output: Returns the current \texttt{frameBuffer} of type FrameData.
\item exception: raises \texttt{CaptureError} if \texttt{hardwareStatus} = $\bot$
                 or frame capture fails.
\end{itemize}

\noindent shutdownHardware():
\begin{itemize}
\item transition: Releases device resources and sets  
      \texttt{hardwareStatus} := $\bot$.
\item output: Returns shutdown success status: $\mathbb{B}$
\item exception: raises \texttt{HardwareShutdownError} if hardware cleanup fails.
\end{itemize}

\noindent isInitialized():
\begin{itemize}
\item transition: -
\item output: returns \texttt{hardwareStatus}: $\mathbb{B}$
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{checkDeviceConnection()}: verifies device presence
\item \texttt{allocateBufferMemory()}: allocates buffer for captured frames
\item \texttt{releaseResources()}: frees hardware-related resources
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Computer Vision Module} \label{M2}

\subsection{Module}
Computer Vision Module (M2)

\subsection{Uses}
\begin{itemize}
    \item \textbf{M1.captureFrame():} Provides a single frame of image data from the hardware or simulated camera.
    \item \textbf{FrameData (Data Type):} Represents the raw image frame used for analysis.
    \item \textbf{GameStateData (Data Type):} Abstract representation of detected game state.
    \item \textbf{ProcessingError, DetectionError (Exception Types):} Raised during processing or detection failures.
    \item \textbf{seq of Elements, dict} (Derived Data Types):  
          Sequences and mappings used to store detected features and confidence metrics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{DETECTION\_THRESHOLD}: $\mathbb{R}$ - minimum required confidence for object recognition
\item \texttt{MODEL\_PATH}: $\Sigma^{*}$ - file system path to trained CV model
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
processFrame & frame:FrameData & GameStateData & ProcessingError \\
detectBoardElements & frame:FrameData & seq of Elements & DetectionError \\
getConfidenceMetrics & - & dict & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{lastFrame}: FrameData \\
      Stores the most recent processed frame.
\item \texttt{lastConfidence}: dict \\
      A mapping from element identifiers ($\Sigma^{*}$) to confidence scores ($\mathbb{R}$).
\end{itemize}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item All \texttt{FrameData} inputs are valid and camera-calibrated.
    \item The model at \texttt{MODEL\_PATH} is present and loaded into memory before use.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent processFrame(frame):
\begin{itemize}
\item transition: Executes the full CV pipeline on $frame$;  
      updates \texttt{lastFrame} := frame.
\item output: Returns detected game state as \texttt{GameStateData}.
\item exception: raises \texttt{ProcessingError} if any stage of the pipeline fails.
\end{itemize}

\noindent detectBoardElements(frame):
\begin{itemize}
\item transition: Runs object detection model on $frame$;  
      updates \texttt{lastFrame} := frame and updates \texttt{lastConfidence}.
\item output: Returns $seq$ of detected Elements.
\item exception: raises \texttt{DetectionError} if detection fails.
\end{itemize}

\noindent getConfidenceMetrics():
\begin{itemize}
\item transition: -
\item output: Returns the \texttt{lastConfidence} mapping (a dict from $\Sigma^{*}$ to $\mathbb{R}$).
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{calibrateCamera()}: Corrects lens distortion in input frames.
\item \texttt{filterNoise()}: Removes low-confidence or spurious detections.
\item \texttt{parseElementsToState()}: Converts detected Elements into \texttt{GameStateData}.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of User Interface Module} \label{M3}

\subsection{Module}
User Interface (M3)

\subsection{Uses}

\begin{itemize}
    \item \textbf{GameStateData}: Abstract representation of the current game state.
    \item \textbf{AIMove}: Encoded AI-generated move.
    \item \textbf{seq of Corrections}: A sequence of user-provided corrections to the game state.
    \item \textbf{RenderError}: Exception raised when visualization or rendering fails.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{REFRESH\_RATE}: $\mathbb{R}$ - frequency of UI updates (Hz)
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
renderBoard & state:GameStateData & - & RenderError \\
displayAIMove & move:AIMove & - & - \\
getUserCorrections & - & seq of Corrections & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{uiState}: Abstract UI representation (type unspecified, internal)
\item \texttt{correctionQueue}: seq of Corrections  
      \quad A sequence of user-provided corrections where each correction may include:
      \begin{itemize}
          \item element identifier: $\Sigma^{*}$
          \item correction value: arbitrary derived type
      \end{itemize}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{window}: graphical display device managed by the environment
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The \texttt{window} device is functional and compatible with the UI rendering framework.
    \item User interactions are delivered to the system via environment-level event handling.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent renderBoard(state):
\begin{itemize}
\item transition: Updates \texttt{uiState} := graphical representation of $state$;  
      renders \texttt{uiState} onto \texttt{window}.
\item output: -
\item exception: raises \texttt{RenderError} if rendering fails.
\end{itemize}

\noindent displayAIMove(move):
\begin{itemize}
\item transition: Updates \texttt{uiState} to include the visualization of $move$;  
      refreshes \texttt{window}.
\item output: -
\item exception: -
\end{itemize}

\noindent getUserCorrections():
\begin{itemize}
\item transition: \texttt{tmp} := \texttt{correctionQueue};  
      \texttt{correctionQueue} := empty sequence.
\item output: Returns \texttt{tmp}: seq of Corrections.
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{updateDOM()}: Updates internal UI representation elements.
\item \texttt{highlightElements()}: Highlights tiles, pieces, or game move indicators.
\item \texttt{onUserInput()}: Adds user-generated corrections to \texttt{correctionQueue}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Game State Manager Module} \label{M4}

\subsection{Module}
Game State Manager (M4)

\subsection{Uses}

\begin{itemize}
    \item \textbf{MoveData}: Represents the details of a player's move, including action type and parameters.
    \item \textbf{GameStateData}: Abstract representation of the complete game state.
    \item \textbf{InvalidMoveError}: Raised when an illegal move is applied.
    \item \textbf{M7.writeState()}: Persists updated game state to storage.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{MAX\_PLAYERS}: $\mathbb{Z}$ = 4
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
updateState & move:MoveData & - & InvalidMoveError \\
getState & - & GameStateData & - \\
validateMove & move:MoveData & $\mathbb{B}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{currentGameState}: GameStateData \\
      The full internal representation of the game board.

\item \texttt{playerAssets}: dict \\
      Mapping from player identifiers ($\Sigma^{*}$) to their resource, structure,  
      and score information. Each value may include:
      \begin{itemize}
          \item resources: dict from resource type ($\Sigma^{*}$) to quantity ($\mathbb{Z}$)
          \item structures: seq of structure types
          \item score: $\mathbb{Z}$
      \end{itemize}
\end{itemize}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item All instances of \texttt{MoveData} conform to the expected internal format.
    \item Calling modules will evaluate \texttt{validateMove(move)} before invoking \texttt{updateState(move)}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent updateState(move):
\begin{itemize}
  \item transition:
  \[
  (
    \texttt{validateMove(move)} = \top \Rightarrow
      \text{\texttt{currentGameState}} := \text{\texttt{applyMove}} (\text{move})
  |
    \texttt{validateMove(move)} = \bot \Rightarrow
      \text{-}
  )
  \]
\item output: -
\item exception: raises \texttt{InvalidMoveError} if \texttt{validateMove(move)} = $\bot$.
\end{itemize}

\noindent getState():
\begin{itemize}
\item transition: -
\item output: Returns a copy of \texttt{currentGameState}: GameStateData.
\item exception: -
\end{itemize}

\noindent validateMove(move):
\begin{itemize}
\item transition: -
\item output: $\mathbb{B}$ - $\top$ iff $move$ is valid according to Catan rules and the
      current values of \texttt{currentGameState} and \texttt{playerAssets}.
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{calculateResources()}: Computes resource changes resulting from a move.
\item \texttt{updateScores()}: Updates player score values based on new state.
\item \texttt{checkVictory()}: Determines whether any player meets winning conditions.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Reinforcement Learning Environment Module} \label{M5}

\subsection{Module}
Reinforcement Learning Environment (M5)

\subsection{Uses}

\begin{itemize}
    \item \textbf{M4}: Uses the access programs 
    \texttt{updateState}, \texttt{getState}, and \texttt{validateMove}.
    \item \textbf{AIMove}: Encoded AI-selected action.
    \item \textbf{GameStateData}: Abstract representation of a full game state.
    \item \textbf{Reward}: A real-valued score, $\mathbb{R}$.
    \item \textbf{StepError, RenderError}: Exceptions raised on invalid steps or rendering failures.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{MAX\_TURNS}: $\mathbb{Z}$ - maximum number of turns in an episode
\item \texttt{REWARD\_SCALE}: $\mathbb{R}$ - scaling factor applied to reward calculation
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
step & action:AIMove & (GameStateData, $\mathbb{R}$) & StepError \\
reset & - & GameStateData & - \\
render & - & - & RenderError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{simulatedState}: internal instance of M4 \\
      Maintains the environment's evolving game state.

\item \texttt{turnCount}: $\mathbb{Z}$ \\
      Number of turns elapsed in the current episode.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{display}: Rendering surface or graphical context used to visualize simulatedState.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item All inputs of type \texttt{AIMove} are syntactically valid.
    \item The environment is responsible for handling opponent moves internally.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent step(action):
\begin{itemize}
\item transition:
The state change is governed by the rule:
\[
(
  \texttt{validateMove(action)} = \top \Rightarrow \text{apply actions}
|
  \texttt{validateMove(action)} = \bot \Rightarrow \text{-}
)
\]
\quad The "apply actions" transition includes the following sequential operations:
\begin{enumerate}
    \item Apply $\texttt{action}$ to $\texttt{simulatedState}$ via $\texttt{updateState(action)}$.
    \item Apply $\texttt{applyOpponentLogic()}$ to simulate adversarial moves.
    \item $\texttt{turnCount} := \texttt{turnCount} + 1$.
\end{enumerate}
\item output:  
      Returns the tuple $(\texttt{simulatedState.getState()}, \texttt{calculateReward()})$  
      of type $(\text{GameStateData}, \mathbb{R})$.
\item exception:  
      raises \texttt{StepError} if $\texttt{validateMove(action)} = \bot$.
\end{itemize}

\noindent reset():
\begin{itemize}
\item transition:  
      \texttt{simulatedState} := new initial game state (via M4).  
      turnCount := 0.
\item output:  
      Returns initial game state: GameStateData.
\item exception: -
\end{itemize}

\noindent render():
\begin{itemize}
\item transition:  
      Updates the \texttt{display} device to visualize the current \texttt{simulatedState}.
\item output: -
\item exception: raises \texttt{RenderError} if display rendering fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{applyOpponentLogic()}: Generates and applies opponent actions based on heuristics or baseline policies.
\item \texttt{calculateReward()}: Returns a reward value in $\mathbb{R}$ based on changes in \texttt{simulatedState}, scaled by \texttt{REWARD\_SCALE}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of AI Model Module} \label{M6}

\subsection{Module}
AI Model (M6)

\subsection{Uses}

\begin{itemize}
    \item \textbf{GameStateData}: Abstract representation of the game state.
    \item \textbf{AIMove}: Encoded move predicted by the model.
    \item \textbf{PredictionError}: Exception raised when the model cannot generate a valid move.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{MODEL\_PATH}: $\Sigma^{*}$ - file path to stored model weights.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
decide & state:GameStateData & AIMove & PredictionError \\
getMoveConfidence & move:AIMove & $\mathbb{R}$ & - \\
explainMove & move:AIMove & $\Sigma^{*}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{modelWeights}: internal representation of learned parameters  
      (vector or tensor values in $\mathbb{R}$ or $\mathbb{R}^{n}$).

\item \texttt{policyNetwork}: An abstract data structure representing the architecture and layers of the DRL model, initialized using \texttt{MODEL\_PATH}.

\item \texttt{lastPredictionCache}: dict mapping AIMove $\rightarrow \mathbb{R}$  
      storing confidence values for the most recent decision.
\end{itemize}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item The input \texttt{GameStateData} conforms to the expected internal structure.
    \item \texttt{MODEL\_PATH} correctly references initialized modelWeights.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent decide(state):
\begin{itemize}
\item transition:
    \begin{itemize}
        \item Converts $state$ using \texttt{preprocessState()}.
        \item Evaluates result  by calling \texttt{evaluatePolicy()}.
        \item Updates \texttt{lastPredictionCache} with move-confidence pairs.
    \end{itemize}

\item output:  
      Returns the optimal AIMove predicted by the model.

\item exception:  
      raises \texttt{PredictionError} if the model evaluation fails or produces an empty distribution.
\end{itemize}

\noindent getMoveConfidence(move):
\begin{itemize}
\item transition: -
\item output:  
      Returns $\mathbb{R}$ - the confidence score associated with $move$  
      retrieved from \texttt{lastPredictionCache}.
\item exception: -
\end{itemize}

\noindent explainMove(move):
\begin{itemize}
\item transition: -
\item output:  
      Returns $\Sigma^{*}$ - a human-readable textual explanation of the rationale  
      behind selecting $move$ (e.g., feature contributions or decision breakdown).
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{preprocessState()}:
      Converts GameStateData into an abstract processed representation suitable  
      for model inference.

\item \texttt{postprocessOutput()}:
      Converts model policy output into a structured AIMove.
\item \texttt{evaluatePolicy()}: \texttt{ProcessedState} $\rightarrow$ \text{dist(AIMove)}
\begin{itemize}
      \item \text{Output}: Returns a probability distribution over possible moves by applying the \texttt{policyNetwork} data structure and \texttt{modelWeights} to the input state.
\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Game State Database Module} \label{M7}

\subsection{Module}
Game State Database (M7)

\subsection{Uses}

\begin{itemize}
    \item \textbf{GameStateData}: Abstract representation of a game state.
    \item \textbf{DBWriteError}: Exception raised on failed write operations.
    \item \textbf{DBReadError}: Exception raised on failed read or query operations.
    \item \textbf{seq(GameStateData)}: Ordered collection of game states.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{DB\_PATH}: $\Sigma^{*}$ - file system path or database URI.
\item \texttt{MAX\_ENTRIES}: $\mathbb{Z}$ - maximum number of stored states.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
writeState & state:GameStateData & - & DBWriteError \\
readState & gameID:$\Sigma^{*}$ & GameStateData & DBReadError \\
queryHistory & playerID:$\Sigma^{*}$ & seq(GameStateData) & DBReadError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{dbConnection}: Active connection handle to the database (abstract type).
\item \texttt{gameRecords}: dict mapping $\Sigma^{*}$ $\rightarrow$ GameStateData  
      (cache of recently accessed or frequently used game states).
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{database}: External file system or DB server located at \texttt{DB\_PATH}.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The database at \texttt{DB\_PATH} is reachable and adheres to the expected schema.
    \item Identifiers such as \texttt{gameID} and \texttt{playerID} are valid $\Sigma^{*}$ strings.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent writeState(state):
\begin{itemize}
\item transition:
    \begin{itemize}
        \item Converts $state$ to a serializable format via \texttt{serializeState()}.
        \item Writes serialized data to \texttt{database}.
        \item Updates \texttt{gameRecords} cache if applicable.
    \end{itemize}
\item output: -
\item exception: raises \texttt{DBWriteError} if the write operation fails.
\end{itemize}

\noindent readState(gameID):
\begin{itemize}
\item transition:
    \begin{itemize}
        \item If $gameID$ is cached, return entry from \texttt{gameRecords}.
        \item Else, load corresponding data from \texttt{database}.
        \item Deserialize via \texttt{deserializeState()}.
        \item Update \texttt{gameRecords}.
    \end{itemize}
\item output: GameStateData corresponding to the given $gameID$.
\item exception: raises \texttt{DBReadError} if no entry exists for $gameID$ or if read fails.
\end{itemize}

\noindent queryHistory(playerID):
\begin{itemize}
\item transition:
    \begin{itemize}
        \item Queries \texttt{database} for all entries linked to $playerID$.
        \item Converts results to seq(GameStateData) via \texttt{deserializeState()}.
    \end{itemize}
\item output: seq(GameStateData) containing all states associated with $playerID$.
\item exception: raises \texttt{DBReadError} if the query fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{serializeState()}: Converts GameStateData into a serializable representation.
\item \texttt{deserializeState()}: Converts stored representation back to GameStateData.
\item \texttt{openConnection()}: Initializes \texttt{dbConnection}.
\item \texttt{closeConnection()}: Terminates \texttt{dbConnection}.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Image Queue Module} \label{M8}

\subsection{Module}
Image Queue (M8)

\subsection{Uses}

\begin{itemize}
    \item \textbf{FrameData}: Abstract representation of an image frame from the camera or simulation.
    \item \textbf{QueueFullError}: Exception raised when attempting to enqueue a frame into a full queue.
    \item \textbf{QueueEmptyError}: Exception raised when attempting to dequeue or peek from an empty queue.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{QUEUE\_SIZE} $\in \mathbb{Z}^{+}$ - maximum number of frames in the buffer.
\item \texttt{TIMEOUT} $\in \mathbb{R}^{+}$ - maximum wait time (seconds) for enqueue/dequeue operations.
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
enqueue & frame:FrameData & $\bot$ & QueueFullError \\
dequeue & - & FrameData & QueueEmptyError \\
peek & - & FrameData & QueueEmptyError \\
isFull & - & $\mathbb{B}$ & - \\
isEmpty & - & $\mathbb{B}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{queueBuffer} : $[0..\text{QUEUE\_SIZE}-1] \rightarrow \text{FrameData} \cup \{\bot\}$ - circular buffer storing frames.
\item \texttt{head} : $\mathbb{Z}$ - index of the front of the queue.
\item \texttt{tail} : $\mathbb{Z}$ - index of the end of the queue.
\item \texttt{size} : $\mathbb{Z}$ - current number of frames in the queue.
\end{itemize}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item Calling modules will check \texttt{isFull()} before \texttt{enqueue()}.
    \item Calling modules will check \texttt{isEmpty()} before \texttt{dequeue()} or \texttt{peek()}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent enqueue(frame: FrameData):
\begin{itemize}
\item transition:  
\[
\text{queueBuffer}[\text{tail}] := \text{frame}, \quad
\text{tail} := (\text{tail} + 1) \bmod \text{QUEUE\_SIZE}, \quad
\text{size} := \text{size} + 1
\]
\item output: -
\item exception: raises \texttt{QueueFullError} if $\text{isFull()} = \top$.
\end{itemize}

\noindent dequeue():
\begin{itemize}
\item transition: frame := queueBuffer[head]; queueBuffer[head] := $\bot$; head := (head+1) mod QUEUE\_SIZE; size := size-1
\item output: frame
\item exception: QueueEmptyError if isEmpty() = $\top$
\end{itemize}

\noindent peek():
\begin{itemize}
\item transition: -
\item output: $\text{queueBuffer}[\text{head}]$
\item exception: raises \texttt{QueueEmptyError} if $\text{isEmpty()} = \top$.
\end{itemize}

\noindent isFull():
\begin{itemize}
\item transition: -
\item output: $\top$ if $\text{size} = \text{QUEUE\_SIZE}$, $\bot$ otherwise
\item exception: -
\end{itemize}

\noindent isEmpty():
\begin{itemize}
\item transition: -
\item output: $\top$ if $\text{size} = 0$, $\bot$ otherwise
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{resetQueue()}:
\[
\text{head} := 0, \quad \text{tail} := 0, \quad \text{size} := 0
\]
Resets the queue to an empty state.
\end{itemize}

%%%%%%%%%END OF MODULES ADDED%%%%%%%%%%%%%%%%%%%%
\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

%\wss{Extra information if required}

\newpage{}

\begin{comment}
\section*{Appendix - Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}

\end{comment}
\end{document}