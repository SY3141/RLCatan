\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{/C:/Users/jaker/OneDrive/Academics/University/Year 4 Courses/Capstone/RLCatan/docs/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
11/03/2025 & 1.0 & Draft Rev 1\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
our project RLCatan. This project aims to create a competent reinforcement learning AI agent designed to master the board game Settlers of Catan through autonomous self-play training. The AI will use deep reinforcement learning algorithms to learn optimal decision-making strategies across several game states including resource management, territory expansion and adaptive responses to opponent actions.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/SY3141/RLCatan}.

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

\multirow{2}{0.3\textwidth}{Hardware-Hiding Module} & Hardware-Hiding Module (OS) \\
& Computer Vision Model \\
\midrule

\multirow{3}{0.3\textwidth}{Behaviour-Hiding Module} &  User Interface \\
&  Game State Manager \\
&  Reinforcement Learning Environment \\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} &  AI Model \\
& Game State Database \\
&  Image Queue \\
\bottomrule

\end{tabular}
\end{table}

\newpage
~\newpage

\section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

%%%%%%%%%%%%%%%%%ADDED MODULES BELOW THIS LINE%%%%%%%%%%%%%%%%%%%%%
\section{MIS of Hardware-Hiding Module} \label{M1}
\wss{Use labels for cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\subsection{Module}
Hardware-Hiding Module (M1)

\subsection{Uses}
FrameData (Data Type): raw image data from camera or simulated source.
HardwareInitError, CaptureError, HardwareShutdownError (Exceptions): error types for hardware operations. 

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{CAMERA\_RESOLUTION} - resolution of captured frames
\item \texttt{FRAME\_RATE} - frames per second captured by the hardware layer
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
initializeHardware & - & - & HardwareInitError \\
captureFrame & - & FrameData & CaptureError \\
shutdownHardware & - & - & HardwareShutdownError \\
isInitialized & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{hardwareStatus}: Boolean - indicates if hardware is initialized
\item \texttt{frameBuffer}: FrameData - stores the latest captured frame
%\item \texttt{State Invariant} - frameBuffer is valid only if hardwareStatus is True
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{CameraDevice} - physical or virtual camera input
\item \texttt{DisplayInterface} - Screen interface for visualization
\end{itemize}

\subsubsection{Assumptions}
The CameraDevice is available and OS drivers are functional.

Calling modules will check isInitialized() before calling captureFrame() or shutdownHardware().

\subsubsection{Access Routine Semantics}

\noindent initializeHardware():
\begin{itemize}
\item transition: Attempts to connect to . If successful, sets hardwareStatus to True
\item output: -
\item exception: raises \texttt{HardwareInitError} if initialization fails
\end{itemize}

\noindent captureFrame():
\begin{itemize}
\item transition: reads a new frame from CameraDevice into frameBuffer
\item output: returns a copy of frameBuffer
\item exception: raises \texttt{CaptureError} if hardwareStatus if False or frame capture fails
\end{itemize}

\noindent shutdownHardware():
\begin{itemize}
\item transition: sets \texttt{hardwareStatus} to False and releases CameraDevice and resources
\item output: -
\item exception: raises \texttt{HardwareShutdownError} if cleanup fails
\end{itemize}

\noindent isInitalized():
\begin{itemize}
\item transition:-
\item output: returns the current value of hardwareStatus
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{checkDeviceConnection()}: ensures camera is available
\item \texttt{allocateBufferMemory()}: manages memory for frame storage
\item \texttt{releaseResources()}: frees hardware resources on shutdown
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Computer Vision Module} \label{M2}

\subsection{Module}
Computer Vision Module (M2)

\subsection{Uses}

M1.captureFrame()

FrameData (Data Type)

GameStateData (Data Type)

ProcessingError (Exception Type)

DetectionError (Exception Type)

List[Elements], Dict (Data Types)

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{DETECTION\_THRESHOLD} - minimum confidence for object recognition
\item \texttt{MODEL\_PATH} - path to trained CV model (YOLOv9/OpenCV)
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
processFrame & frame:FrameData & GameStateData & ProcessingError \\
detectBoardElements & frame:FrameData & List[Elements] & DetectionError \\
getConfidenceMetrics & - & Dict & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{lastFrame}: FrameData - last processed frame
\item \texttt{lastCofidence}: Dict - confidence scores for last detections
\end{itemize}
\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
Assumes FrameData provided is valid and preprocessed for analysis.
Assumes model files at MODEL\_PATH are loaded correctly before use.

\subsubsection{Access Routine Semantics}

\noindent processFrame(frame):
\begin{itemize}
\item transition: Runs full CV pipeline on frame to extract game state. Updates LastFrame to frame.
\item output: returns \texttt{GameStateData} object representing detected board state
\item exception: raises \texttt{ProcessingError} if parsing fails
\end{itemize}

\noindent detectBoardElements(frame):
\begin{itemize}
\item transition: Runs detection model on frame. Updates lastFrame to frame and updates lastConfidence.
\item output: returns list of detected board elements (tiles, pieces, numbers)
\item exception: raises \texttt{DetectionError} if detection fails
\end{itemize}

\noindent getConfidenceMetrics():
\begin{itemize}
\item transition: -
\item output: returns confidence scores for last processed frame
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{calibrateCamera()}: adjusts image for lens distortion
\item \texttt{filterNoise()}: removes spurious detections
\item \texttt{parseElementsToState()}: converts detected elements to GameStateData
\end{itemize}

\section{MIS of User Interface Module} \label{M3}

\subsection{Module}
User Interface (M3)

\subsection{Uses}
GameStateData (Data Type)

AIMove (Data Type)

List[Corrections] (Data Type)

RenderError (Exception Type)

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{REFRESH\_RATE} - frequency of UI updates
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
renderBoard & state:GameStateData & - & RenderError \\
displayAIMove & move:AIMove & - & - \\
getUserCorrections & - & List[Corrections] & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{uiState}: current UI rendering data
\item \texttt{correctionQueue}: list of user inputted corrections
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item window: graphical display device
\end{itemize}

\subsubsection{Assumptions}
The window environment is compatible with the frontend framework.

\subsubsection{Access Routine Semantics}

\noindent renderBoard(state):
\begin{itemize}
\item transition: Modifies uiState to match state. Updates the window to visualize the new uiState.
\item output: -
\item exception: raises \texttt{RenderError} if rendering to the window fails
\end{itemize}

\noindent displayAIMove(move):
\begin{itemize}
\item transition: Modifies uiState to include a visualization of the move. Updates the window.
\item output: -
\item exception: -
\end{itemize}

\noindent getUserCorrections():
\begin{itemize}
\item transition: clears correctionQueue
\item output: returns the current list of user corrections for misdetected board state
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{updateDOM()}: handles DOM updates in the window
\item \texttt{highlightElements()}: highlights tiles, pieces, or moves
\item \texttt{onUserInput()}: Internal event handler that adds user actions to correction Queue
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Game State Manager Module} \label{M4}

\subsection{Module}
Game State Manager (M4)

\subsection{Uses}
MoveData (Data Type)

GameStateData (Data Type)

InvalidMoveError (Exception Type)

M7.writeState() (from Game State Database Module)

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{MAX\_PLAYERS} = 4
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
updateState & move:MoveData & - & InvalidMoveError \\
getState & - & GameStateData & - \\
validateMove & move:MoveData & Boolean & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{currentGameState}: the full "Digital Twin" of the Catan board.
\item \texttt{playerAssets}: A collection tracking each players resources,settlements,roads,etc.
\end{itemize}

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
Assumes MoveData is provided in the standard, non-corrupt format.

Assumes calling module will use validateMove before attempting updateState.

\subsubsection{Access Routine Semantics}

\noindent updateState(move):
\begin{itemize}
\item transition: iff validateMove(move) is True, the move is applied to currentGameState and playerAssets are updated.
\item output: -
\item exception: raises \texttt{InvalidMoveError} if move is False
\end{itemize}

\noindent getState():
\begin{itemize}
\item transition: -
\item output: returns a copy of the current \texttt{currentGameState} and playerAssests as GameStateData
\item exception: -
\end{itemize}

\noindent validateMove(move):
\begin{itemize}
\item transition: -
\item output: Returns True if the move is a legal action according to the rules of Catan given the currentGameState, False otherwise.
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{calculateResources()} : computes resource changes from moves
\item \texttt{updateScores()} : updates players score
\item \texttt{checkVictory()} : checks if any player has won
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Reinforcement Learning Environment Module} \label{M5}

\subsection{Module}
Reinforcement Learning Environment (M5)

\subsection{Uses}
M4.updateState

M4.getState

M4.validateMove

AIMove (Data Type)

GameStateData (Data Type)

Reward (Data Type, e.g., Float)

StepError (Exception Type)

RenderError (Exception Type)

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{MAX\_TURNS}
\item \texttt{REWARD\_SCALE}
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
step & action:AIMove & GameStateData, Reward & StepError \\
reset & - & GameStateData & - \\
render & - & - & RenderError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{simulatedState} : An internal instance of M4 to manage the simulation
\item \texttt{turnCount} : the number of turns elapsed in the current episode
\end{itemize}

\subsubsection{Environment Variables}
\texttt{display}: the graphical output window or context used to visualize the simulation

\subsubsection{Assumptions}
Assumes AIMove actions are provided in the valid, non-corrupt format.

\subsubsection{Access Routine Semantics}

\noindent step(action):
\begin{itemize}
\item transition: Applies action to simulatedState using M4. Runs opponent logic. Increments turnCount.
\item output: Returns the new state (from simulatedState.getState()) and the calculated Reward.
\item exception: raises \texttt{StepError} if action is invalid
\end{itemize}

\noindent reset():
\begin{itemize}
\item transition: Resets simulatedState to a new initial game. Resets turnCount to 0.
\item output: Returns the initial simulatedState.getState().
\item exception: -
\end{itemize}

\noindent render():
\begin{itemize}
\item transition: Modifies the display environment variable to show a visualization of simulatedState.
\item output: -
\item exception: raises \texttt{RenderError}  if the display fails
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{applyOpponentLogic()} : Simulates opponent moves
\item \texttt{calculateReward()}: computes reward based on change in simulatedState
\end{itemize}

\section{MIS of AI Model Module} \label{M6}

\subsection{Module}
AI Model (M6)

\subsection{Uses}
GameStateData (Data Type)

AIMove (Data Type)

PredictionError (Exception Type)

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{MODEL\_PATH} - path to trained neural network weights
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{5cm} p{3cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
predictMove & state:GameStateData & AIMove & PredictionError \\
getMoveConfidence & move:AIMove & Float & - \\
explainMove & move:AIMove & String & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{modelWeights} - the loaded neural network parameters
\item \texttt{policyNetwork} - DRL policy network
\item \texttt{lastPredictionCache} - cache the last predictions outputs for getMoveConfidence
\end{itemize}

\subsubsection{Environment Variables}
N/A
\subsubsection{Assumptions}
Assumes input GameStateData is valid.

Assumes model weights at MODEL\_PATH are loaded correctly before use.

\subsubsection{Access Routine Semantics}

\noindent predictMove(state):
\begin{itemize}
\item transition: Evaluates state with policyNetwork. Caches results in lastPredictionCache.
\item output: Returns the optimal AIMove.
\item exception: raises \texttt{PredictionError} if model fails to evaluate the state
\end{itemize}

\noindent getMoveConfidence(move):
\begin{itemize}
\item transition: -
\item output: Returns a Float (e.g., 0.0-1.0) representing the confidence score for the specified move, retrieved from lastPredictionCache.
\item exception: -
\end{itemize}

\noindent explainMove(move):
\begin{itemize}
\item transition: -
\item output: returns a human-readable String explanation of why the model selected the move.
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{preprocessState()}: Converts GameStateData into model input format
\item \texttt{postprocessOutput()}: Converts model output into a strctured AImove
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Game State Database Module} \label{M7}

\subsection{Module}
Game State Database (M7)

\subsection{Uses}
GameStateData (Data Type)

DBWriteError (Exception Type)

DBReadError (Exception Type)

List[GameStateData] (Data Type)

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{DB\_PATH} - database file or server location
\item \texttt{MAX\_ENTRIES} - maximum stored states
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
writeState & state:GameStateData & - & DBWriteError \\
readState & gameID:String & GameStateData & DBReadError \\
queryHistory & playerID:String & List[GameStateData] & DBReadError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{dbConnection} - active connection to the database
\item \texttt{gameRecords} - cached recently accessed game records
\end{itemize}

\subsubsection{Environment Variables}
\texttt{database} - external file system at DB\_PATH

\subsubsection{Assumptions}
Assumes the database is accessible and the schema matches the expected structure.

\subsubsection{Access Routine Semantics}

\noindent writeState(state):
\begin{itemize}
\item transition: Serializes and writes the state to the database.
\item output: -
\item exception: DBWriteError if the write operation fails.
\end{itemize}

\noindent readState(gameID):
\begin{itemize}
\item transition: Retrieves and deserializes the game state for the specified gameID.
\item output: returns \texttt{GameStateData} for specified game
\item exception: raises \texttt{DBReadError} if gameID is not found or read fails
\end{itemize}

\noindent queryHistory(playerID):
\begin{itemize}
\item transition: Queries the database for all game states associated with playerID.
\item output: returns list of \texttt{GameStateData} for given player
\item exception: raises \texttt{DBReadError} if query fails
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{serializeState()} : converts GameStateData to storable format
\item \texttt{deserializeState()} : converts stored format back to GameStateData
\item \texttt{openConnection()} : establishes dbConnection
\item \texttt{closeConnection()} : terminates dbConnection
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{MIS of Image Queue Module} \label{M8}

\subsection{Module}
Image Queue (M8)

\subsection{Uses}
FrameData (Data Type)

QueueFullError (Exception Type)

QueueEmptyError (Exception Type)
\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
\item \texttt{QUEUE\_SIZE} - maximum buffer size
\item \texttt{TIMEOUT} - maximum wait time for enqueue/dequeue
\end{itemize}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
enqueue & frame:FrameData & - & QueueFullError \\
dequeue & - & FrameData & QueueEmptyError \\
peek & - & FrameData & QueueEmptyError \\
isFull & - & Boolean & - \\
isEmpty & - & Boolean & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{queueBuffer} - stores frames in order
\item \texttt{head} - pointer to front of the queue
\item \texttt{tail} - pointer to end of the queue
\item \texttt{size} - current number of frames in the queue

\end{itemize}

\subsubsection{Environment Variables}
- None

\subsubsection{Assumptions}
Calling modules will check isFull() before enqueue().

Calling modules will check isEmpty() before dequeue() or peek().
\subsubsection{Access Routine Semantics}

\noindent enqueue(frame):
\begin{itemize}
\item transition: Adds frame to queueBuffer at tail. Increments tail and size.
\item output: returns True if successful
\item exception: raises QueueFullError if isFull() is True.
\end{itemize}

\noindent dequeue():
\begin{itemize}
\item transition: Removes the frame from queueBuffer at head. Increments head and decrements size.
\item output: Returns the FrameData from the head.
\item exception: raises \texttt{QueueEmptyError} if isEmpty() is True.
\end{itemize}

\noindent peek():
\begin{itemize}
\item transition: -
\item output: returns next FrameData without removing it from queueBuffer.
\item exception: raises \texttt{QueueEmptyError} if isEmpty() is True
\end{itemize}

\noindent isFull():
\begin{itemize}
\item transition: -
\item output: returns True if size == QUEUE\_SIZE, False otherwise
\item exception: -
\end{itemize}

\noindent isEmpty():
\begin{itemize}
\item transition: -
\item output: returns True if size == 0, False otherwise
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item  \texttt{resetQueue()} : Resets head, tail, and size.
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}