\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{\hyperref[sec:#1]{M\ref*{#1}}}

\begin{document}

\title{Module Guide for \progname{}}
\author{\authname}
\date{November 13th, 2025}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
11/13/2025 & 1.0 & Draft Rev 1\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l}
  \toprule
  \textbf{symbol} & \textbf{description}\\
  \midrule
  AC & Anticipated Change\\
  AI & Artificial Intelligence \\
  CV & Computer Vision \\
  DAG & Directed Acyclic Graph \\
  FR & Functional Requirement \\
  M & Module \\
  MG & Module Guide \\
  NFR & Non-Functional Requirement \\
  OS & Operating System \\
  R & Requirement\\
  RL & Reinforcement Learning \\
  SRS & Software Requirements Specification\\
  UC & Unlikely Change \\
  UI & User Interface \\
  VnV & Verification and Validation \\
  \bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing software.
A module is a work assignment for a programmer or programming team~\citep{ParnasEtAl1984}.
We advocate a decomposition based on the principle of information hiding~\citep{Parnas1972a}.
This principle supports design for change, because the ``secrets'' that each module hides represent likely future changes.


Our design follows the rules layed out by \citet{ParnasEtAl1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data structures must obtain it by calling access programs belonging to that module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\citep{ParnasEtAl1984}.
The MG specifies the modular structure of the system and is intended to allow both designers and maintainers to easily identify the parts of the software.


The rest of the document is organized as follows. Section
\ref{SecChange} lists the anticipated and unlikely changes of the software requirements.
Section \ref{SecMH} summarizes the module decomposition that was constructed according to the likely changes.
Section \ref{SecConnection} specifies the connections between the software requirements and the
modules.
Section \ref{SecMD} gives a detailed description of the modules.
Section \ref{SecTM} includes two traceability matrices.
One checks the completeness of the design against the requirements provided in the SRS\@.
The other shows the relation between anticipated changes and the modules.
Section
\ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system.
According to the likeliness of the change, the possible changes are classified into two categories.
Anticipated changes are listed in Section \ref{SecAchange}, and unlikely changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden inside the modules.
Ideally, changing one of the anticipated changes will only require changing the one module that hides the associated decision.


\begin{description}
\item[\refstepcounter{acnum} \actheacnum \label{acAIModel}:] The specific architecture, heuristics, and reward functions of the RL agent.
These will be iterated on constantly to improve performance.
\item[\refstepcounter{acnum} \actheacnum \label{acCVModel}:] The specific CV algorithm or model (e.g., YOLOv9 vs.
OpenCV) used for board state detection.
This may be changed to improve accuracy or adapt to different lighting conditions.
\item[\refstepcounter{acnum} \actheacnum \label{acUI}:] The layout and design of the User Interface.
This will likely change based on user feedback to improve usability.
\item[\refstepcounter{acnum} \actheacnum \label{acSimulator}:] The underlying Catan simulator (Catanatron).
This is an external library that may be updated or replaced.
\item[\refstepcounter{acnum} \actheacnum \label{acDatabase}:] The specific schema or technology (e.g., SQL vs NoSQL) for the Game State Database, as post-game analysis needs may evolve.
\item[\refstepcounter{acnum} \actheacnum \label{acComm}:] The communication protocol (e.g., 0MQ) used by the Image Queue.
This might be swapped for another low-latency middleware like WebSockets.
\end{description}

\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible.
However, fixing some design decisions at the system architecture stage can simplify the software design.
It is not intended that these decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum \label{ucGameRules}:] The fundamental rules of the standard Settlers of Catan base game.
The project is not intended to support expansions.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucArchitecture}:] The core architectural decomposition.
The system will always require separate components for vision, state management, AI, and a user interface.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucTechStack}:] The primary technology stack choices of Python for the backend/AI and JavaScript/React for the frontend.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucInputSource}:] The fundamental premise of reading from a physical game board via a camera, as opposed to being a purely digital application.
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design.
Modules are summarized in a hierarchy decomposed by secrets in Table \ref{TblMH}.
The modules listed below, which are leaves in the hierarchy tree, are the modules that will actually be implemented.

\begin{description}
\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module (OS)
\item [\refstepcounter{mnum} \mthemnum \label{mCV}:] Computer Vision Model
\item [\refstepcounter{mnum} \mthemnum \label{mUI}:] User Interface
\item [\refstepcounter{mnum} \mthemnum \label{mState}:] Game State Manager
\item [\refstepcounter{mnum} \mthemnum \label{mEnv}:] Reinforcement Learning Environment
\item [\refstepcounter{mnum} \mthemnum \label{mAI}:] AI Model
\item [\refstepcounter{mnum} \mthemnum \label{mDB}:] Game State Database
\item [\refstepcounter{mnum} \mthemnum \label{mQueue}:] Image Queue (Communication Layer)
\end{description}


\begin{table}[h!]
\centering
\caption{Module Hierarchy}
    \label{TblMH}
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

\multirow{2}{0.3\textwidth}{Hardware-Hiding Module} & \mref{mHH}: Hardware-Hiding Module (OS) \\
& \mref{mCV}: Computer Vision Model \\
\midrule

\multirow{3}{0.3\textwidth}{Behaviour-Hiding Module} & \mref{mUI}: User Interface \\
& \mref{mState}: Game State Manager \\
& \mref{mEnv}: Reinforcement Learning Environment \\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} & \mref{mAI}: AI Model \\
& \mref{mDB}: Game State Database \\
& \mref{mQueue}: Image Queue \\
\bottomrule

\end{tabular}
\end{table}

\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in
the SRS.
To satisfy the requirements for real-time operation (NFR.E.4), low-latency communication (FR.S.6.3), and component decoupling (NFR.S.3), a design decision was made to use a message queue middleware (as implemented in \mref{mQueue}) for asynchronous communication between the primary components. This allows the CV, AI, and UI modules to operate independently without blocking each other.

\section{Module Decomposition} \label{SecMD}

Modules are decomposed according to the principle of ``information hiding''
proposed by \citet{ParnasEtAl1984}.
The \emph{Secrets} field in a module
decomposition is a brief statement of the design decision hidden by the
module.
The \emph{Services} field specifies \emph{what} the module will do
without documenting \emph{how} to do it.


\subsection{Hardware Hiding Modules}

\subsubsection{Hardware-Hiding Module (\mref{mHH})} \label{sec:mHH}
\begin{description}
\item[Secrets:]The data structure and algorithm used to implement the virtual
  hardware.
This includes the drivers for the camera hardware.
\item[Services:]Serves as a virtual hardware used by the rest of the
  system.
This module provides the interface between the hardware (camera) and the
  software.

\item[Implemented By:] OS
\end{description}

\subsubsection{Computer Vision Model (\mref{mCV})} \label{sec:mCV}
\begin{description}
\item[Secrets:]The specific algorithms, libraries (e.g., OpenCV, YOLOv9), and trained models used to interpret a raw video/image feed and detect the physical board layout, pieces, and player actions. Hides the complexity of calibration and error correction.
\item[Services:]Provides access programs to process camera input, detect board elements, and translate visual features into a structured digital representation of the game state. Provides diagnostic feedback on detection confidence.
\item[Implemented By:] \progname{}
\end{description}

\subsection{Behaviour-Hiding Module}
\begin{description}
\item[Secrets:]The contents of the required behaviours.
\item[Services:]Includes programs that provide externally visible behaviour of
  the system as specified in the SRS.
This module serves as a communication layer between the
  hardware-hiding module and the software decision module.

\item[Implemented By:] --
\end{description}

\subsubsection{User Interface (\mref{mUI})} \label{sec:mUI}
\begin{description}
\item[Secrets:]The specific frontend framework (React, JavaScript) and UI/UX design choices used to render the game state and AI suggestions. Hides the details of DOM manipulation and event handling.
\item[Services:]Provides an interactive, real-time visualization of the Catan board. Displays player moves, resources, and AI-generated move recommendations. Allows users to provide manual corrections to the board state (to satisfy FR.Sa.1).
\item[Implemented By:] \progname{}
\end{description}

\subsubsection{Game State Manager (\mref{mState})} \label{sec:mState}
\begin{description}
\item[Secrets:]The internal data structure and logic that represent the "Digital Twin" of the Catan board. Hides the complex logic used to enforce the official Catan ruleset and ensure state synchronization.
\item[Services:]Maintains the single source of truth for the current game state. Tracks player assets and turn data. Provides access programs to update the state and validate all player and AI moves against the game rules.
\item[Implemented By:] \progname{}
\end{description}

\subsubsection{Reinforcement Learning Environment (\mref{mEnv})} \label{sec:mEnv}
\begin{description}
\item[Secrets:]The implementation details of the Catan game simulator (Catanatron). Hides the specific reward/penalty functions and opponent logic used during AI self-play and training.
\item[Services:]Simulates the game rules and state transitions of Catan. Provides an interface for the AI model to interact with, perform self-play, and receive feedback for learning. Supports model evaluation and benchmarking.
\item[Implemented By:] \progname{} (as a wrapper around Catanatron)
\end{description}

\subsection{Software Decision Module}
\begin{description}
\item[Secrets:] The design decision based on mathematical theorems, physical
  facts, or programming considerations.
The secrets of this module are
  \emph{not} described in the SRS.
\item[Services:] Includes data structure and algorithms used in the system that
  do not provide direct interaction with the user.
\item[Implemented By:] --
\end{description}

\subsubsection{AI Model (\mref{mAI})} \label{sec:mAI}
\begin{description}
\item[Secrets:]The specific DRL model architecture (e.g., deep neural network parameters), heuristics, and trained weights used to determine the optimal move. Hides the complex mathematical formulation of the policy $\pi(a \mid s)$.
\item[Services:]Analyzes a given digital game state to predict optimal player strategies. Provides access programs to request move recommendations, confidence scores, and textual reasoning.
\item[Implemented By:] \progname{}
\end{description}

\subsubsection{Game State Database (\mref{mDB})} \label{sec:mDB}
\begin{description}
\item[Secrets:]The specific database technology (e.g., SQL, NoSQL) and schema used to store and retrieve game history. Hides the implementation of data persistence, transactions, and indexing.
\item[Services:]Stores and maintains complete and consistent records of all game states and player profiles. Provides access programs for efficient read/write operations and structured access to historical game data for post-game analysis or replay.
\item[Implemented By:] \progname{}
\end{description}

\subsubsection{Image Queue (\mref{mQueue})} \label{sec:mQueue}
\begin{description}
\item[Secrets:]The specific data transfer protocol and middleware (e.g., 0MQ/imageMQ) used for low-latency, asynchronous communication between modules. Hides the details of message serialization, authentication, and error handling.
\item[Services:]Enables reliable, low-latency data exchange between the CV Model, Game State Manager, AI Model, and UI. Supports asynchronous message-passing mechanisms.
\item[Implemented By:] \progname{}
\end{description}

\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

\begin{table}[H]
\centering
\caption{Trace Between Requirements and Modules}
\label{TblRT}
\begin{tabularx}{\textwidth}{|l|X|}
\toprule
\textbf{Requirement(s)} & \textbf{Modules}\\
\midrule
FR.S.1.x (CV Model) & \mref{mCV} \\
\hline
FR.S.2.x (RL Environment) & \mref{mEnv} \\
\hline
FR.S.3.x (AI Model) & \mref{mAI} \\
\hline
FR.S.4.x (User Interface) & \mref{mUI} \\
\hline
FR.S.5.x (Game State DB) & \mref{mDB} \\
\hline
FR.S.6.x (Image Queue) & \mref{mQueue} \\
\hline
FR.S.7.x (Game State Mgr) & \mref{mState} \\
\hline
NFR.S.1 (Scalability) & \mref{mAI}, \mref{mQueue}, \mref{mDB} \\
\hline
NFR.S.2 (Usability) & \mref{mUI} \\
\hline
NFR.S.3 (Maintainability) & \mref{mAI}, \mref{mCV}, \mref{mState}, \mref{mUI} (All) \\
\hline
NFR.S.4 (Installability) & \mref{mHH} \\
\hline
NFR.S.5 (Data Integrity) & \mref{mDB}, \mref{mState} \\
\hline
NFR.S.6 (Availability) & \mref{mQueue}, \mref{mDB} \\
\hline
FR.Sa.1, FR.Sa.2, FR.Sa.4, FR.Sa.7, FR.Sa.8, NFR.Sa.1 (UI/Feedback Safety) & \mfref{mUI} \\
\hline
FR.Sa.3 (AI Validation) & \mref{mState}, \mref{mAI} \\
\hline
FR.Sa.5 (DB Safety) & \mref{mDB} \\
\hline
FR.Sa.6, NFR.Sa.2 (Connection Safety) & \mref{mQueue} \\
\hline
FR.Sa.9, FR.Sa.11 (CV Safety) & \mref{mCV} \\
\hline
FR.Sa.10 (AI Rollback) & \mref{mAI} \\
\hline
FR.Sa.12 (Env. Validation) & \mref{mEnv} \\
\bottomrule
\end{tabularx}
\end{table}

\begin{table}[H]
\centering
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\begin{tabular}{|l|l|}
\toprule
\textbf{Anticipated Change (AC)} & \textbf{Modules}\\
\midrule
\acref{acAIModel} & \mref{mAI} \\
\hline
\acref{acCVModel} & \mref{mCV} \\
\hline
\acref{acUI} & \mref{mUI} \\
\hline
\acref{acSimulator} & \mref{mEnv} \\
\hline
\acref{acDatabase} & \mref{mDB} \\
\hline
\acref{acComm} & \mref{mQueue} \\
\bottomrule
\end{tabular}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is provided.
A module A uses a module B if the correct execution of A depends upon the availability of a correct implementation of B. For our system, the 'uses' relation is not a simple hierarchy, as the main components communicate in a decoupled manner through the Communication Layer (\mref{mQueue}). The relationships are shown in Figure \ref{FigUH}. This graph is a directed acyclic graph (DAG), as required.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{component_diagram}
\caption{Component diagram showing use hierarchy among modules.}
\label{FigUH}
\end{figure}

\section{User Interfaces}

The detailed design of the User Interface (\mref{mUI}) will be documented using Figma wireframes and mockups. These design artifacts are attached as an appendix to this document (or will be available at a shared link). The design focuses on satisfying NFR.S.2 (Usability) and the specific UI-related safety requirements (e.g., FR.Sa.1, FR.Sa.7).

\section{Design of Communication Protocols}

The system's modules communicate via the \mref{mQueue} module. This module implements a publish-subscribe protocol. The design of this protocol is defined by the message topics and data structures (schemas) that are shared between modules.

Key communication topics will include:
\begin{itemize}
    \item \texttt{cv.board.update}: Published by \mref{mCV}, consumed by \mref{mState}. Carries structured data of detected board changes.
    \item \texttt{state.game.update}: Published by \mmref{mState}, consumed by \mref{mUI} and \mref{mAI}. Carries the new authoritative game state.
    \item \texttt{ai.request.move}: Published by \mref{mUI} (or other clients), consumed by \mref{mAI}. Requests a move suggestion for the current state.
    \item \texttt{ai.response.move}: Published by \mref{mAI}, consumed by \mref{mUI}. Provides the suggested optimal move.
\end{itemize}
The precise JSON or Protobuf schemas for these messages will be defined in the Module Interface Specification (MIS).

\section{Timeline}

The schedule of tasks, milestones, and team member responsibilities is maintained on our GitHub Project Kanban board, as specified in the Development Plan. This allows for dynamic tracking of progress. The board can be accessed here: \href{https://github.com/users/SY3141/projects/1}{github.com/users/SY3141/projects/1}

\bibliographystyle{plainnat}

\bibliography{../../../refs/References}

\newpage{}

\end{document}